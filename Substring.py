def boyer_moore(text, pattern): # объявление функции
    m = len(pattern) # длина шаблона
    n = len(text) # длина текста
    if m > n: # если длина шаблона больше длины текста, возвращаем пустой список
        return [] 

    skip = [] # создание пустого списка "skip"
    for k in range(256): # итерация по всем возможным символам ASCII таблицы
        skip.append(m) # инициализация списка "skip" значением "m" для каждого символа
    for k in range(m - 1): # итерация по всем символам шаблона, кроме последнего
        skip[ord(pattern[k])] = m - k - 1 # для символа "pattern[k]" вычисляем расстояние до его последнего вхождения в шаблоне

    result = [] # создание пустого списка "result"
    i = 0 # инициализация переменной "i" значением 0
    while i <= n - m: # выполнение цикла пока "i" не станет больше, чем разность длин текста и шаблона
        j = m - 1 # инициализация переменной "j" значением "m - 1"
        while j >= 0 and pattern[j] == text[i+j]: # выполнение цикла пока "j" больше или равно нулю и символы на позициях "j" в шаблоне и "i+j" в тексте равны
            j -= 1 # уменьшение значения переменной "j" на 1
        if j < 0: # если значение переменной "j" меньше нуля, то все символы шаблона были совпадающими с соответствующими символами текста
            result.append(i) # добавление позиции "i" в список "result"
            i += skip[ord(text[i+m])] if i+m < n else 1 # установка нового значения переменной "i" с помощью элемента списка "skip" со значением, соответствующим символу на позиции "i+m" в тексте
        else: # если значение переменной "j" больше или равно нулю, то есть были несовпадающие символы
            i += max(1, j - skip[ord(text[i+j])]) # установка нового значения переменной "i" с помощью максимума из 1 и разности между "j" и элементом списка "skip" со значением, соответствующим символу на позиции "i+j" в тексте
    return result # возвращение списка "result" содержащего позиции вхождения шаблона в текст



def rabin_karp(text, pattern): # Функция Rabin-Karp для поиска подстроки в строке
    m = len(pattern) # Длина подстроки
    n = len(text) # Длина строки
    if m > n: # Если подстрока длиннее строки, то она не может быть в ней
        return [] # Возвращаем пустой массив

    result = [] # Массив для хранения индексов, в которых найдена подстрока
    p = 0 # Хеш подстроки
    t = 0 # Хеш текущего окна
    h = 1 # Значение для вычисления хеша
    d = 256 # Размер алфавита
    q = 101 # Простое число, близкое к размеру алфавита

    for i in range(m-1): # Вычисляем h
        h = (h*d) % q # Формула из алгоритма Рабина-Карпа

    for i in range(m): # Вычисляем хеши подстроки и первого окна
        p = (d*p + ord(pattern[i])) % q # Хеш подстроки
        t = (d*t + ord(text[i])) % q # Хеш первого окна

    for i in range(n-m+1): # Проходим по всем окнам в строке
        if p == t: # Если хеши совпали, проверяем подстроку на совпадение
            match = True # Флаг для проверки совпадения подстроки
            for j in range(m): # Проходим по всем символам подстроки
                if pattern[j] != text[i+j]: # Если символы не совпали
                    match = False # Подстрока не совпадает
                    break # Прерываем цикл
            if match: # Если все символы совпали
                result.append(i) # Добавляем индекс начала подстроки в результаты

        if i < n-m: # Если не конец строки
            t = (d*(t-ord(text[i])*h) + ord(text[i+m])) % q # Вычисляем хеш для следующего окна

            if t < 0: # Если хеш отрицательный, преобразуем его в положительный
                t += q # Формула из алгоритма Рабина-Карпа

    return result # Возвращаем результаты поиска



def kmp(text, pattern): # Функция KMP для поиска подстроки в тексте
    m = len(pattern) # Длина подстроки
    n = len(text) # Длина текста
    if m > n: # Если длина подстроки больше длины текста, то не может быть вхождений
        return [] #

    pi = [0] * m # Массив длины m, для хранения значений префикс-функции
    result = [] # Массив для хранения индексов вхождений подстроки в текст
    j = 0 # Индекс текущего символа в подстроке

    compute_prefix_function(pattern, pi) # Вычисляем префикс-функцию для подстроки

    for i in range(n): # Итерируемся по всем символам текста
        while j > 0 and pattern[j] != text[i]: # Сдвигаем индекс j, пока символы не совпадают
            j = pi[j-1] #

        if pattern[j] == text[i]: # Если символы совпадают
            j += 1 # Увеличиваем индекс j

        if j == m: # Если весь шаблон был найден
            result.append(i-m+1) # Добавляем индекс начала найденного вхождения в результат
            j = pi[j-1] # Сдвигаем индекс j на длину найденного префикса

    return result # Возвращаем список индексов начала вхождений подстроки в текст


def compute_prefix_function(pattern, pi): # Функция для вычисления префикс-функции для подстроки
    m = len(pattern) # Длина подстроки
    k = 0 # Индекс символа в подстроке, с которого начинается сравнение
    pi[0] = 0 # Значение префикс-функции для первого символа всегда равно 0

    for i in range(1, m): # Итерируемся по всем символам подстроки, начиная со второго
        while k > 0 and pattern[k] != pattern[i]: # Сдвигаем индекс k, пока символы не совпадают
            k = pi[k-1] #

        if pattern[k] == pattern[i]: # Если символы совпадают
            k += 1 # Увеличиваем индекс k

        pi[i] = k # Записываем найденную длину префикса для текущего символа


